\documentclass[11pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}

\title{XEQUES: Proof-of-Command-Correctness}
\author{Prajwal Aher}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
XEQUES introduces Proof-of-Command-Correctness (PoCC), a Layer-1
trust primitive where autonomous devices emit cryptographically
verifiable execution receipts after executing authorized commands.
\end{abstract}

\section{Execution Semantics}
Devices are modeled as deterministic state machines.

\section{Receipt Definition}
Receipts bind command, state transition, and execution effects.

\section{Safety Lemma}
Receipt forgery implies compromise of the device private key.

\end{document}

\section{Formal Invariants}

\subsection{Invariant 1: Execution Authenticity}

\textbf{Implication:} A valid receipt cannot be produced without execution.

\subsection{Invariant 2: Non-Equivocation}
A device MUST NOT produce two distinct receipts for the same
command sequence number that imply different execution effects.

\textbf{Implication:} Conflicting histories are cryptographically detectable.

\subsection{Invariant 3: Causal Ordering}
Receipts encode a monotonic state transition.

\subsection{Invariant 4: Offline Verifiability}
Receipt verification requires only public data:
the command, the receipt, and the device public key.

\textbf{Implication:} Auditors can verify execution correctness
without device access or network connectivity.

\section{Threat Model}

XEQUES assumes a powerful adversary with extensive network and cryptographic capabilities.

\subsection{Adversary Capabilities}
\begin{itemize}
\item Full network observation, delay, replay, and reordering
\item Compromise of command authorities
\item Physical capture of devices (excluding private key extraction)
\item Long-term quantum computational capability
\item Access to all published receipts and logs
\end{itemize}

\subsection{Adversary Limitations}
\begin{itemize}
\item Cannot forge post-quantum digital signatures
\item Cannot extract private keys from uncompromised devices
\item Cannot alter device execution semantics without detection
\end{itemize}

\subsection{Out-of-Scope Attacks}
\begin{itemize}
\item Side-channel extraction of device private keys
\item Malicious firmware replacing execution logic
\item Denial-of-service attacks
\end{itemize}

\subsection{Security Objective}
XEQUES guarantees that any accepted receipt corresponds to a real execution
of an authorized command, even under quantum-capable adversaries.

\section{Cryptographic Foundations}

XEQUES relies on standard cryptographic primitives with
post-quantum security guarantees.

\subsection{Digital Signatures}
Each authority and device possesses a long-term post-quantum
signature keypair.

The signature scheme MUST provide:
\begin{itemize}
\item Existential unforgeability under chosen-message attacks (EUF-CMA)
\item Security against quantum adversaries
\item Deterministic or strongly bound randomized signing
\end{itemize}

Concrete instantiations include Dilithium or equivalent NIST PQC finalists.

\subsection{Hash Functions}
All receipts bind execution data using a collision-resistant hash function.

The hash function MUST provide:
\begin{itemize}
\item Collision resistance
\item Preimage resistance
\item Second-preimage resistance
\end{itemize}

Standard SHA-2 or SHA-3 family functions are sufficient.

\subsection{No Trusted Randomness Assumption}
XEQUES does not require trusted randomness during verification.
All security properties remain verifiable offline.

\subsection{Cryptographic Trust Boundary}
If a valid receipt verifies under a device public key,
the protocol treats the corresponding execution as final.

Breaking this guarantee implies a break of the underlying
post-quantum signature scheme.

\section{Protocol Flow}

XEQUES defines a minimal two-phase protocol between an Authority and a Device.

\subsection{Phase 1: Command Authorization}
An authority constructs a command message:

\[
m = (cmd\_id, device\_id, payload, seq)
\]

The authority signs the command:

\[
\sigma_A = \text{Sign}_{sk_A}(H(m))
\]


\subsection{Phase 2: Execution and Receipt Emission}
Upon receipt, the device verifies $\sigma_A$ and checks sequence monotonicity.

If verification succeeds, the device executes the command:

\[
(s', e) = \delta(s, cmd)
\]

The device then constructs an execution receipt:

\[
r = (cmd\_id, device\_id, s, s', e, seq)
\]

and signs it:

\[
\sigma_D = \text{Sign}_{sk_D}(H(r))
\]


\section{Formal Invariants}

\subsection{Invariant 1: Execution Authenticity}
Every valid receipt corresponds to an actual device execution.

\textbf{Justification:} Forging a receipt implies forging a post-quantum signature.

\subsection{Invariant 2: Non-Repudiation}
A device cannot deny executing a command once a valid receipt is published.

\subsection{Invariant 3: Order Preservation}
Monotonic sequence numbers prevent command replay and reordering.

\subsection{Invariant 4: Offline Verifiability}
Any third party can verify execution correctness without contacting the device.

\subsection{Invariant 5: Execution Finality}
Once a receipt verifies, execution is final and irreversible.
