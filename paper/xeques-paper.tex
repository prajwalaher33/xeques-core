\documentclass[11pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}

\title{XEQUES: Proof-of-Command-Correctness}
\author{Prajwal Aher}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
XEQUES introduces Proof-of-Command-Correctness (PoCC), a Layer-1
trust primitive where autonomous devices emit cryptographically
verifiable execution receipts after executing authorized commands.
\end{abstract}

\section{Execution Semantics}
Devices are modeled as deterministic state machines.

\section{Receipt Definition}
Receipts bind command, state transition, and execution effects.

\section{Safety Lemma}
Receipt forgery implies compromise of the device private key.

\end{document}

\section{Formal Invariants}

\subsection{Invariant 1: Execution Authenticity}

\textbf{Implication:} A valid receipt cannot be produced without execution.

\subsection{Invariant 2: Non-Equivocation}
A device MUST NOT produce two distinct receipts for the same
command sequence number that imply different execution effects.

\textbf{Implication:} Conflicting histories are cryptographically detectable.

\subsection{Invariant 3: Causal Ordering}
Receipts encode a monotonic state transition.

\subsection{Invariant 4: Offline Verifiability}
Receipt verification requires only public data:
the command, the receipt, and the device public key.

\textbf{Implication:} Auditors can verify execution correctness
without device access or network connectivity.

\section{Threat Model}

XEQUES assumes a powerful adversary with extensive network and cryptographic capabilities.

\subsection{Adversary Capabilities}
\begin{itemize}
\item Full network observation, delay, replay, and reordering
\item Compromise of command authorities
\item Physical capture of devices (excluding private key extraction)
\item Long-term quantum computational capability
\item Access to all published receipts and logs
\end{itemize}

\subsection{Adversary Limitations}
\begin{itemize}
\item Cannot forge post-quantum digital signatures
\item Cannot extract private keys from uncompromised devices
\item Cannot alter device execution semantics without detection
\end{itemize}

\subsection{Out-of-Scope Attacks}
\begin{itemize}
\item Side-channel extraction of device private keys
\item Malicious firmware replacing execution logic
\item Denial-of-service attacks
\end{itemize}

\subsection{Security Objective}
XEQUES guarantees that any accepted receipt corresponds to a real execution
of an authorized command, even under quantum-capable adversaries.

\section{Cryptographic Foundations}

XEQUES relies on standard cryptographic primitives with
post-quantum security guarantees.

\subsection{Digital Signatures}
Each authority and device possesses a long-term post-quantum
signature keypair.

The signature scheme MUST provide:
\begin{itemize}
\item Existential unforgeability under chosen-message attacks (EUF-CMA)
\item Security against quantum adversaries
\item Deterministic or strongly bound randomized signing
\end{itemize}

Concrete instantiations include Dilithium or equivalent NIST PQC finalists.

\subsection{Hash Functions}
All receipts bind execution data using a collision-resistant hash function.

The hash function MUST provide:
\begin{itemize}
\item Collision resistance
\item Preimage resistance
\item Second-preimage resistance
\end{itemize}

Standard SHA-2 or SHA-3 family functions are sufficient.

\subsection{No Trusted Randomness Assumption}
XEQUES does not require trusted randomness during verification.
All security properties remain verifiable offline.

\subsection{Cryptographic Trust Boundary}
If a valid receipt verifies under a device public key,
the protocol treats the corresponding execution as final.

Breaking this guarantee implies a break of the underlying
post-quantum signature scheme.

\section{Protocol Flow}

XEQUES defines a minimal two-phase protocol between an Authority and a Device.

\subsection{Phase 1: Command Authorization}
An authority constructs a command message:

\[
m = (cmd\_id, device\_id, payload, seq)
\]

The authority signs the command:

\[
\sigma_A = \text{Sign}_{sk_A}(H(m))
\]


\subsection{Phase 2: Execution and Receipt Emission}
Upon receipt, the device verifies $\sigma_A$ and checks sequence monotonicity.

If verification succeeds, the device executes the command:

\[
(s', e) = \delta(s, cmd)
\]

The device then constructs an execution receipt:

\[
r = (cmd\_id, device\_id, s, s', e, seq)
\]

and signs it:

\[
\sigma_D = \text{Sign}_{sk_D}(H(r))
\]


\section{Formal Invariants}

\subsection{Invariant 1: Execution Authenticity}
Every valid receipt corresponds to an actual device execution.

\textbf{Justification:} Forging a receipt implies forging a post-quantum signature.

\subsection{Invariant 2: Non-Repudiation}
A device cannot deny executing a command once a valid receipt is published.

\subsection{Invariant 3: Order Preservation}
Monotonic sequence numbers prevent command replay and reordering.

\subsection{Invariant 4: Offline Verifiability}
Any third party can verify execution correctness without contacting the device.

\subsection{Invariant 5: Execution Finality}
Once a receipt verifies, execution is final and irreversible.

\section{Normative Protocol Requirements}

The following requirements use the terminology defined in RFC 2119.

\subsection{Authority Requirements}
\begin{itemize}
\item Authorities \textbf{MUST} sign every command using a post-quantum secure signature scheme.
\item Authorities \textbf{MUST} include a monotonically increasing sequence number per device.
\item Authorities \textbf{MUST NOT} reuse sequence numbers for the same device.
\end{itemize}

\subsection{Device Requirements}
\begin{itemize}
\item Devices \textbf{MUST} verify authority signatures before execution.
\item Devices \textbf{MUST} reject commands with stale or non-monotonic sequence numbers.
\item Devices \textbf{MUST} emit exactly one receipt per executed command.
\item Devices \textbf{MUST NOT} emit receipts without executing the command.
\end{itemize}

\subsection{Receipt Requirements}
\begin{itemize}
\item Receipts \textbf{MUST} cryptographically bind the command, pre-state, post-state, and execution effect.
\item Receipts \textbf{MUST} be signed with a device-unique private key.
\item Receipts \textbf{SHOULD} be verifiable offline by third parties.
\end{itemize}

\subsection{Verifier Requirements}
\begin{itemize}
\item Verifiers \textbf{MUST} validate receipt signatures before accepting execution correctness.
\item Verifiers \textbf{MUST NOT} trust execution claims without a valid receipt.
\end{itemize}

\subsection{Security Guarantees}
Any implementation conforming to this specification guarantees:
\begin{itemize}
\item Execution authenticity
\item Non-repudiation of device actions
\item Replay and reordering resistance
\item Post-quantum security assumptions
\end{itemize}

\section{Abstract}

Autonomous infrastructure systems rely on cryptographic authorization to accept commands, but existing systems authenticate intent rather than execution. We introduce \emph{XEQUES}, a Layer-1 protocol that formalizes \emph{Proof-of-Command-Correctness (PoCC)}: cryptographically verifiable execution receipts emitted by devices after executing authorized commands. XEQUES enables post-quantum secure, offline-verifiable execution finality for long-lived autonomous systems such as satellites, power grids, and industrial robotics. Unlike blockchains or traditional PKI, XEQUES treats execution itself as the unit of trust.

\section{Introduction}

Modern autonomous systems operate under delayed connectivity, adversarial environments, and long operational lifetimes. While cryptographic signatures authenticate command authorization, they do not prove that a command was actually executed. This gap becomes critical in safety- and mission-critical systems.

XEQUES addresses this gap by introducing execution receipts as a first-class trust primitive. Devices emit cryptographically signed receipts only after executing verified commands, allowing third parties to independently validate execution correctness without trusting the issuing authority.

\section{Contributions}

This work makes the following contributions:
\begin{itemize}
\item A new Layer-1 trust primitive: Proof-of-Command-Correctness (PoCC).
\item A formal execution and receipt model for autonomous devices.
\item A post-quantum secure protocol design supporting offline verification.
\item A reference implementation demonstrating feasibility.
\end{itemize}

\section{Related Work}

Traditional PKI systems authenticate command origin but do not attest to execution. Blockchain-based systems provide ordering and consensus but are ill-suited for high-latency or disconnected environments. Secure logging and attestation systems partially address execution integrity but typically require trusted hardware assumptions.

XEQUES differs by treating execution receipts as a Layer-1 primitive, independent of consensus, enabling verification under post-quantum threat models and long-lived device constraints.

\section{Threat Model}

We assume an adversary with full network visibility and control, capable of replaying, delaying, reordering, or suppressing messages. The adversary may compromise command authorities and obtain their private keys. The adversary may possess quantum computational capabilities sufficient to break classical cryptographic schemes.

We assume devices protect their private keys from extraction. Physical compromise of a device constitutes total device compromise and is outside the protocol scope.

\section{Security Guarantees}

\subsection{Theorem 1 (Execution Authenticity)}

\textbf{Statement.} Any valid execution receipt must correspond to an actual execution of the associated command on the device.

\textbf{Proof Sketch.} A receipt is generated only after evaluating the deterministic execution function $\delta$. Producing a valid receipt without execution requires forging a post-quantum signature under the device key, contradicting signature unforgeability.

\subsection{Theorem 2 (Authority Independence)}

\textbf{Statement.} Verification of execution receipts does not require trust in the command authority.

\textbf{Proof Sketch.} Receipt verification depends solely on the device public key and the receipt contents. Even if the authority is malicious or compromised, it cannot produce execution receipts without device participation.

\subsection{Theorem 3 (Replay Resistance)}

\textbf{Statement.} XEQUES prevents replayed commands from producing valid execution receipts.

\textbf{Proof Sketch.} Receipts bind monotonically increasing sequence numbers and prior state hashes. Replayed commands violate sequence or state consistency and are rejected by the device.

\subsection{Corollary (Offline Verifiability)}

Execution receipts may be verified offline without interaction with the device or authority, provided the verifier possesses the device public key.

\section{Protocol Invariants}

XEQUES maintains a set of global invariants that hold for all valid executions and receipts.

\subsection{Invariant 1 (Monotonic Execution)}


\textbf{Implication.} Devices cannot skip, reorder, or retroactively insert executions.

\subsection{Invariant 2 (State Continuity)}


\textbf{Implication.} Forked or divergent execution histories are detectable and invalid.

\subsection{Invariant 3 (Single-Receipt Finality)}

For a given device and sequence number, at most one valid receipt may exist.

\textbf{Implication.} Execution equivocation is cryptographically prevented.

\section{State Safety}

\subsection{Safety Theorem}

\textbf{Statement.} No two conflicting execution histories for the same device can both be accepted by a correct verifier.

\textbf{Proof Sketch.} Conflicting histories imply either duplicate sequence numbers or inconsistent state hashes. Both violate receipt validity conditions and are rejected.

\subsection{Crash and Restart Safety}

A device may safely restart by persisting only its last accepted receipt. All prior state may be reconstructed or verified from the receipt log.

\textbf{Implication.} XEQUES supports long-lived, intermittently powered devices.

\section{Comparison to Existing Systems}

XEQUES addresses a trust gap not covered by blockchains, PKI, or secure logging systems.

\subsection{Public-Key Infrastructure (PKI)}

PKI proves \emph{who} issued a command but provides no cryptographic proof that a command was executed. Authorization and execution are decoupled.

\textbf{Limitation.} A valid signature does not imply that the device acted.

\subsection{Blockchains and Distributed Ledgers}

Blockchains provide globally ordered logs and economic finality. However, they do not observe or verify real-world execution.

\textbf{Limitation.} Blockchains finalize \emph{statements}, not physical actions.

\subsection{Secure Audit Logs}

Secure logs attest that a system recorded an event, but the log itself is not cryptographically bound to physical execution.

\textbf{Limitation.} Logs can be written without execution unless the device is trusted.

\subsection{XEQUES Distinction}

XEQUES collapses authorization, execution, and attestation into a single cryptographic act.

Execution receipts are produced \emph{iff} execution occurs, making forgery equivalent to device compromise.

\textbf{Result.} XEQUES introduces execution-finality as a Layer-1 trust primitive.

\section{Limitations and Non-Goals}

XEQUES is intentionally minimal. This section clarifies what the protocol does not attempt to solve.

\subsection{No Global Consensus}

XEQUES does not provide ordering, leader election, or consensus among devices.

Receipt validity is independent of global agreement and can be verified offline.

\subsection{No Economic Security Model}

XEQUES does not rely on staking, slashing, or incentives. Its security rests solely on cryptographic unforgeability and device key integrity.

\subsection{No Execution Enforcement}

XEQUES cannot prevent a compromised device from refusing to execute a command.

However, it prevents a device from falsely claiming execution without cryptographic evidence.

\subsection{Physical World Assumptions}

XEQUES assumes that device execution faithfully reflects physical action.

Sensor spoofing, actuator sabotage, and hardware faults are explicitly out of scope.

\subsection{Key Compromise}

If a device private key is compromised, an attacker may generate valid receipts.

Key rotation, revocation, and registry governance are left to higher layers.

\subsection{Intentional Minimalism}

XEQUES defines a single primitive: execution-finality.

All networking, aggregation, storage, and governance layers are optional extensions.

\textbf{Design principle:} A protocol that does less, but proves more.
