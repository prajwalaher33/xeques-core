\documentclass[11pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}

\title{XEQUES: Proof-of-Command-Correctness}
\author{Prajwal Aher}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
XEQUES introduces Proof-of-Command-Correctness (PoCC), a Layer-1
trust primitive where autonomous devices emit cryptographically
verifiable execution receipts after executing authorized commands.
\end{abstract}

\section{Execution Semantics}
Devices are modeled as deterministic state machines.

\section{Receipt Definition}
Receipts bind command, state transition, and execution effects.

\section{Safety Lemma}
Receipt forgery implies compromise of the device private key.

\end{document}

\section{Formal Invariants}

\subsection{Invariant 1: Execution Authenticity}

\textbf{Implication:} A valid receipt cannot be produced without execution.

\subsection{Invariant 2: Non-Equivocation}
A device MUST NOT produce two distinct receipts for the same
command sequence number that imply different execution effects.

\textbf{Implication:} Conflicting histories are cryptographically detectable.

\subsection{Invariant 3: Causal Ordering}
Receipts encode a monotonic state transition.

\subsection{Invariant 4: Offline Verifiability}
Receipt verification requires only public data:
the command, the receipt, and the device public key.

\textbf{Implication:} Auditors can verify execution correctness
without device access or network connectivity.

\section{Threat Model}

XEQUES assumes a powerful adversary with extensive network and cryptographic capabilities.

\subsection{Adversary Capabilities}
\begin{itemize}
\item Full network observation, delay, replay, and reordering
\item Compromise of command authorities
\item Physical capture of devices (excluding private key extraction)
\item Long-term quantum computational capability
\item Access to all published receipts and logs
\end{itemize}

\subsection{Adversary Limitations}
\begin{itemize}
\item Cannot forge post-quantum digital signatures
\item Cannot extract private keys from uncompromised devices
\item Cannot alter device execution semantics without detection
\end{itemize}

\subsection{Out-of-Scope Attacks}
\begin{itemize}
\item Side-channel extraction of device private keys
\item Malicious firmware replacing execution logic
\item Denial-of-service attacks
\end{itemize}

\subsection{Security Objective}
XEQUES guarantees that any accepted receipt corresponds to a real execution
of an authorized command, even under quantum-capable adversaries.

\section{Cryptographic Foundations}

XEQUES relies on standard cryptographic primitives with
post-quantum security guarantees.

\subsection{Digital Signatures}
Each authority and device possesses a long-term post-quantum
signature keypair.

The signature scheme MUST provide:
\begin{itemize}
\item Existential unforgeability under chosen-message attacks (EUF-CMA)
\item Security against quantum adversaries
\item Deterministic or strongly bound randomized signing
\end{itemize}

Concrete instantiations include Dilithium or equivalent NIST PQC finalists.

\subsection{Hash Functions}
All receipts bind execution data using a collision-resistant hash function.

The hash function MUST provide:
\begin{itemize}
\item Collision resistance
\item Preimage resistance
\item Second-preimage resistance
\end{itemize}

Standard SHA-2 or SHA-3 family functions are sufficient.

\subsection{No Trusted Randomness Assumption}
XEQUES does not require trusted randomness during verification.
All security properties remain verifiable offline.

\subsection{Cryptographic Trust Boundary}
If a valid receipt verifies under a device public key,
the protocol treats the corresponding execution as final.

Breaking this guarantee implies a break of the underlying
post-quantum signature scheme.

\section{Protocol Flow}

XEQUES defines a minimal two-phase protocol between an Authority and a Device.

\subsection{Phase 1: Command Authorization}
An authority constructs a command message:

\[
m = (cmd\_id, device\_id, payload, seq)
\]

The authority signs the command:

\[
\sigma_A = \text{Sign}_{sk_A}(H(m))
\]


\subsection{Phase 2: Execution and Receipt Emission}
Upon receipt, the device verifies $\sigma_A$ and checks sequence monotonicity.

If verification succeeds, the device executes the command:

\[
(s', e) = \delta(s, cmd)
\]

The device then constructs an execution receipt:

\[
r = (cmd\_id, device\_id, s, s', e, seq)
\]

and signs it:

\[
\sigma_D = \text{Sign}_{sk_D}(H(r))
\]


\section{Formal Invariants}

\subsection{Invariant 1: Execution Authenticity}
Every valid receipt corresponds to an actual device execution.

\textbf{Justification:} Forging a receipt implies forging a post-quantum signature.

\subsection{Invariant 2: Non-Repudiation}
A device cannot deny executing a command once a valid receipt is published.

\subsection{Invariant 3: Order Preservation}
Monotonic sequence numbers prevent command replay and reordering.

\subsection{Invariant 4: Offline Verifiability}
Any third party can verify execution correctness without contacting the device.

\subsection{Invariant 5: Execution Finality}
Once a receipt verifies, execution is final and irreversible.

\section{Normative Protocol Requirements}

The following requirements use the terminology defined in RFC 2119.

\subsection{Authority Requirements}
\begin{itemize}
\item Authorities \textbf{MUST} sign every command using a post-quantum secure signature scheme.
\item Authorities \textbf{MUST} include a monotonically increasing sequence number per device.
\item Authorities \textbf{MUST NOT} reuse sequence numbers for the same device.
\end{itemize}

\subsection{Device Requirements}
\begin{itemize}
\item Devices \textbf{MUST} verify authority signatures before execution.
\item Devices \textbf{MUST} reject commands with stale or non-monotonic sequence numbers.
\item Devices \textbf{MUST} emit exactly one receipt per executed command.
\item Devices \textbf{MUST NOT} emit receipts without executing the command.
\end{itemize}

\subsection{Receipt Requirements}
\begin{itemize}
\item Receipts \textbf{MUST} cryptographically bind the command, pre-state, post-state, and execution effect.
\item Receipts \textbf{MUST} be signed with a device-unique private key.
\item Receipts \textbf{SHOULD} be verifiable offline by third parties.
\end{itemize}

\subsection{Verifier Requirements}
\begin{itemize}
\item Verifiers \textbf{MUST} validate receipt signatures before accepting execution correctness.
\item Verifiers \textbf{MUST NOT} trust execution claims without a valid receipt.
\end{itemize}

\subsection{Security Guarantees}
Any implementation conforming to this specification guarantees:
\begin{itemize}
\item Execution authenticity
\item Non-repudiation of device actions
\item Replay and reordering resistance
\item Post-quantum security assumptions
\end{itemize}

\section{Abstract}

Autonomous infrastructure systems rely on cryptographic authorization to accept commands, but existing systems authenticate intent rather than execution. We introduce \emph{XEQUES}, a Layer-1 protocol that formalizes \emph{Proof-of-Command-Correctness (PoCC)}: cryptographically verifiable execution receipts emitted by devices after executing authorized commands. XEQUES enables post-quantum secure, offline-verifiable execution finality for long-lived autonomous systems such as satellites, power grids, and industrial robotics. Unlike blockchains or traditional PKI, XEQUES treats execution itself as the unit of trust.

\section{Introduction}

Modern autonomous systems operate under delayed connectivity, adversarial environments, and long operational lifetimes. While cryptographic signatures authenticate command authorization, they do not prove that a command was actually executed. This gap becomes critical in safety- and mission-critical systems.

XEQUES addresses this gap by introducing execution receipts as a first-class trust primitive. Devices emit cryptographically signed receipts only after executing verified commands, allowing third parties to independently validate execution correctness without trusting the issuing authority.

\section{Contributions}

This work makes the following contributions:
\begin{itemize}
\item A new Layer-1 trust primitive: Proof-of-Command-Correctness (PoCC).
\item A formal execution and receipt model for autonomous devices.
\item A post-quantum secure protocol design supporting offline verification.
\item A reference implementation demonstrating feasibility.
\end{itemize}

\section{Related Work}

Traditional PKI systems authenticate command origin but do not attest to execution. Blockchain-based systems provide ordering and consensus but are ill-suited for high-latency or disconnected environments. Secure logging and attestation systems partially address execution integrity but typically require trusted hardware assumptions.

XEQUES differs by treating execution receipts as a Layer-1 primitive, independent of consensus, enabling verification under post-quantum threat models and long-lived device constraints.

\section{Threat Model}

We assume an adversary with full network visibility and control, capable of replaying, delaying, reordering, or suppressing messages. The adversary may compromise command authorities and obtain their private keys. The adversary may possess quantum computational capabilities sufficient to break classical cryptographic schemes.

We assume devices protect their private keys from extraction. Physical compromise of a device constitutes total device compromise and is outside the protocol scope.

\section{Security Guarantees}

\subsection{Theorem 1 (Execution Authenticity)}

\textbf{Statement.} Any valid execution receipt must correspond to an actual execution of the associated command on the device.

\textbf{Proof Sketch.} A receipt is generated only after evaluating the deterministic execution function $\delta$. Producing a valid receipt without execution requires forging a post-quantum signature under the device key, contradicting signature unforgeability.

\subsection{Theorem 2 (Authority Independence)}

\textbf{Statement.} Verification of execution receipts does not require trust in the command authority.

\textbf{Proof Sketch.} Receipt verification depends solely on the device public key and the receipt contents. Even if the authority is malicious or compromised, it cannot produce execution receipts without device participation.

\subsection{Theorem 3 (Replay Resistance)}

\textbf{Statement.} XEQUES prevents replayed commands from producing valid execution receipts.

\textbf{Proof Sketch.} Receipts bind monotonically increasing sequence numbers and prior state hashes. Replayed commands violate sequence or state consistency and are rejected by the device.

\subsection{Corollary (Offline Verifiability)}

Execution receipts may be verified offline without interaction with the device or authority, provided the verifier possesses the device public key.

\section{Protocol Invariants}

XEQUES maintains a set of global invariants that hold for all valid executions and receipts.

\subsection{Invariant 1 (Monotonic Execution)}


\textbf{Implication.} Devices cannot skip, reorder, or retroactively insert executions.

\subsection{Invariant 2 (State Continuity)}


\textbf{Implication.} Forked or divergent execution histories are detectable and invalid.

\subsection{Invariant 3 (Single-Receipt Finality)}

For a given device and sequence number, at most one valid receipt may exist.

\textbf{Implication.} Execution equivocation is cryptographically prevented.

\section{State Safety}

\subsection{Safety Theorem}

\textbf{Statement.} No two conflicting execution histories for the same device can both be accepted by a correct verifier.

\textbf{Proof Sketch.} Conflicting histories imply either duplicate sequence numbers or inconsistent state hashes. Both violate receipt validity conditions and are rejected.

\subsection{Crash and Restart Safety}

A device may safely restart by persisting only its last accepted receipt. All prior state may be reconstructed or verified from the receipt log.

\textbf{Implication.} XEQUES supports long-lived, intermittently powered devices.

\section{Comparison to Existing Systems}

XEQUES addresses a trust gap not covered by blockchains, PKI, or secure logging systems.

\subsection{Public-Key Infrastructure (PKI)}

PKI proves \emph{who} issued a command but provides no cryptographic proof that a command was executed. Authorization and execution are decoupled.

\textbf{Limitation.} A valid signature does not imply that the device acted.

\subsection{Blockchains and Distributed Ledgers}

Blockchains provide globally ordered logs and economic finality. However, they do not observe or verify real-world execution.

\textbf{Limitation.} Blockchains finalize \emph{statements}, not physical actions.

\subsection{Secure Audit Logs}

Secure logs attest that a system recorded an event, but the log itself is not cryptographically bound to physical execution.

\textbf{Limitation.} Logs can be written without execution unless the device is trusted.

\subsection{XEQUES Distinction}

XEQUES collapses authorization, execution, and attestation into a single cryptographic act.

Execution receipts are produced \emph{iff} execution occurs, making forgery equivalent to device compromise.

\textbf{Result.} XEQUES introduces execution-finality as a Layer-1 trust primitive.

\section{Limitations and Non-Goals}

XEQUES is intentionally minimal. This section clarifies what the protocol does not attempt to solve.

\subsection{No Global Consensus}

XEQUES does not provide ordering, leader election, or consensus among devices.

Receipt validity is independent of global agreement and can be verified offline.

\subsection{No Economic Security Model}

XEQUES does not rely on staking, slashing, or incentives. Its security rests solely on cryptographic unforgeability and device key integrity.

\subsection{No Execution Enforcement}

XEQUES cannot prevent a compromised device from refusing to execute a command.

However, it prevents a device from falsely claiming execution without cryptographic evidence.

\subsection{Physical World Assumptions}

XEQUES assumes that device execution faithfully reflects physical action.

Sensor spoofing, actuator sabotage, and hardware faults are explicitly out of scope.

\subsection{Key Compromise}

If a device private key is compromised, an attacker may generate valid receipts.

Key rotation, revocation, and registry governance are left to higher layers.

\subsection{Intentional Minimalism}

XEQUES defines a single primitive: execution-finality.

All networking, aggregation, storage, and governance layers are optional extensions.

\textbf{Design principle:} A protocol that does less, but proves more.

\section{Liveness and Availability}

XEQUES distinguishes between \emph{execution liveness} and \emph{receipt availability}.

\subsection{Execution Liveness}

XEQUES does not guarantee that a device will execute a valid command.

Devices may be offline, partitioned, damaged, or policy-restricted.

Failure to produce a receipt is treated as non-execution rather than protocol failure.

\subsection{Receipt Availability}

Receipt availability is orthogonal to execution.

Receipts may be delayed, buffered, or transmitted asynchronously without affecting validity.

Verification does not require real-time connectivity to the issuing authority.

\subsection{Offline and Partitioned Operation}

XEQUES explicitly supports disconnected operation.

Receipts remain verifiable indefinitely once obtained.

\subsection{Replay and Suppression}

Command replay is prevented through monotonic sequencing bound into receipts.

Receipt suppression is detectable through missing sequence numbers.

\subsection{Liveness Safety Property}

XEQUES guarantees the following:

\begin{quote}
\textbf{If a valid receipt exists, then the corresponding execution occurred.}
\end{quote}

The converse is intentionally not guaranteed.

\section{Formal Invariants}

XEQUES maintains the following protocol invariants:

\begin{itemize}
\item \textbf{Execution Soundness:} A valid receipt implies real execution.
\item \textbf{Non-Repudiation:} Devices cannot deny executed commands.
\item \textbf{Non-Fabrication:} Receipts cannot be produced without execution.
\item \textbf{Offline Verifiability:} Verification does not require network access.
\item \textbf{Monotonic Progress:} Sequence numbers strictly increase per device.
\end{itemize}

These invariants hold assuming post-quantum signature unforgeability.

\section{Related Work}

Traditional blockchains provide ordering and consensus but do not prove execution.

Public Key Infrastructure (PKI) authenticates identities but not actions.

Trusted Execution Environments (TEEs) rely on hardware trust assumptions.

XEQUES differs by treating \emph{execution receipts} as a Layer-1 primitive,
independent of ordering, consensus, or trusted hardware.

\section{Conclusion}

XEQUES introduces Proof-of-Command-Correctness (PoCC),
a new Layer-1 trust primitive for autonomous systems.

By elevating execution receipts to first-class cryptographic objects,
XEQUES enables offline, post-quantum verifiable command finality.

This work opens a new design space for secure control of
long-lived, safety-critical infrastructure.

\section*{arXiv Submission Note}

This document is intended for public dissemination via arXiv
under the Cryptography and Security (cs.CR) category.
\section{Security Considerations}

XEQUES shifts the unit of trust from authorization to execution.
This section clarifies failure modes and residual risks.

\subsection{Key Compromise}

If a device private key is compromised, an adversary may forge
execution receipts. This is equivalent to full device compromise
and is considered outside the protocol threat model.

Key rotation and hardware-backed key storage are RECOMMENDED.

\subsection{Authority Compromise}

If an authority key is compromised, adversaries may issue
unauthorized commands. However, execution receipts remain
verifiable and auditable post-facto.

XEQUES separates command issuance from execution finality.

\subsection{Replay and Reordering Attacks}

Commands are bound to monotonic sequence numbers.
Devices MUST reject commands with stale or repeated sequence
values.

\subsection{Quantum Adversaries}

XEQUES assumes post-quantum secure signature schemes.
If these primitives fail, the protocol offers no additional
cryptographic fallback.

\subsection{Non-Goals}

XEQUES does not provide:
\begin{itemize}
\item Byzantine fault tolerance
\item Global consensus
\item Transaction ordering
\item Economic incentives
\end{itemize}

These properties are intentionally excluded to minimize
the trusted computing base.
% ================================
% XEQUES — Formal Layer-1 Sections
% ================================

\section{Execution Semantics}

We model the device as a deterministic state machine:

\[
D = (S, C, E, \delta)
\]

where \( S \) is device state, \( C \) commands, and \( \delta \) execution.

A receipt is produced if and only if execution occurs.

\section{Correctness Theorem}

\textbf{Theorem.}
A receipt verifies under device public key \( pk_D \)
if and only if the device executed the command.

\textbf{Proof Sketch.}
Receipt signatures are unforgeable.
Hashes bind command, state, and effects.
Thus forging a receipt implies device key compromise.

\section{Protocol Flow}

\begin{enumerate}
\item Authority signs command using PQ signature
\item Device verifies signature and sequence
\item Device executes command
\item Device emits signed execution receipt
\item Any verifier validates receipt offline
\end{enumerate}

% ================================
% ================================
% XEQUES — Paper Structure
% ================================

\section{Abstract}
(To be completed)

\section{Introduction}
(To be completed)

\section{Related Work}
(To be completed)

\section{Threat Model}
(To be completed)

\section{Cryptographic Assumptions}
(To be completed)

\section{Security Invariants}
(To be completed)

\section{Conclusion}
(To be completed)

% ================================
\section{Abstract}

We introduce \textbf{XEQUES}, a Layer-1 protocol that formalizes
\emph{execution itself} as a cryptographically verifiable primitive.
Unlike blockchains, which establish consensus over ordering, or
traditional PKI systems, which authenticate identity, XEQUES
establishes \emph{execution finality} through device-emitted,
post-quantum secure execution receipts.

Each authorized command, once executed by an autonomous device,
produces a signed receipt binding the command, pre-state, post-state,
and execution effect. These receipts are independently verifiable,
offline-auditable, and do not rely on global consensus or continuous
connectivity.

XEQUES enables long-lived autonomous infrastructure—such as satellites,
industrial systems, and critical infrastructure—to prove correct
command execution even in adversarial or disconnected environments.
We formalize the execution semantics, security invariants, and threat
model, and present a reference implementation demonstrating feasibility.

\section{Threat Model}

XEQUES is designed for adversarial environments where communication
channels, authorities, and long-lived devices may be partially or fully
compromised.

\subsection{Adversarial Capabilities}

We assume an adversary with the following capabilities:

\begin{itemize}
\item Full network visibility, including interception, replay, and reordering of commands
\item Ability to compromise or impersonate command authorities
\item Long-term storage of observed traffic for future cryptanalysis
\item Quantum-capable computation against classical cryptographic schemes
\end{itemize}

\subsection{Adversarial Limitations}

We assume the adversary \emph{cannot}:

\begin{itemize}
\item Forge post-quantum secure signatures without access to device private keys
\item Alter the internal execution function of a correctly functioning device
\item Produce a valid execution receipt without actual command execution
\end{itemize}

\subsection{Trust Assumptions}

XEQUES minimizes trust assumptions:

\begin{itemize}
\item Authorities may be compromised after command issuance
\item Devices may be offline for extended periods
\item Verification may occur long after execution
\end{itemize}

The sole root of trust is the device-held private key used to sign
execution receipts.

\subsection{Security Objective}

The primary security objective of XEQUES is:

\begin{quote}
\textbf{To make unauthorized or unexecuted commands
cryptographically indistinguishable from non-events.}
\end{quote}

An adversary who cannot produce a valid receipt cannot convince any
verifier that a command was executed.

\section{Cryptographic Assumptions and Primitives}

XEQUES relies on post-quantum secure cryptographic primitives.

\subsection{Signature Scheme}
Each device possesses a post-quantum secure keypair.

\subsection{Hash Function}
A collision-resistant hash binds execution state.

\subsection{Sequencing and Freshness}
Monotonic sequence numbers prevent replay attacks.

\subsection{Security Guarantee}
Receipt forgery implies compromise of the device secret key.

\section{Protocol Flow}

This section specifies the end-to-end execution and verification flow of XEQUES.

\subsection{Actors}
\begin{itemize}
\item Authority: Issues authorized commands
\item Device: Executes commands and emits receipts
\item Verifier: Independently validates execution
\end{itemize}

\subsection{Command Issuance}
The Authority signs a command using a post-quantum signature scheme.
Each command includes a unique sequence number and validity constraints.

\subsection{Command Verification}
Upon receipt, the Device verifies the Authority signature.
Invalid or replayed commands are rejected prior to execution.

\subsection{Execution}
If verification succeeds, the Device executes the command deterministically.
Execution produces a new internal state and observable effect.

\subsection{Receipt Generation}
After execution, the Device constructs an execution receipt.
The receipt binds the command, prior state, resulting state, and effects.

\subsection{Receipt Publication}
Receipts may be stored locally, transmitted, or published to an append-only log.
XEQUES does not mandate a global consensus layer.

\subsection{Verification}
Any Verifier can independently validate a receipt offline.
Successful verification implies the command was executed as claimed.

\subsection{Finality Property}
Execution is final once a valid receipt exists.
No external ordering or confirmation is required.

\section{Security Invariants and Theorems}

XEQUES is defined by a small set of security invariants.
These invariants hold independently of network topology, availability, or consensus.

\subsection{Invariant 1: Execution Authenticity}
A valid receipt implies the command was executed by the claimed device.
This follows from the unforgeability of the device signature key.

\subsection{Invariant 2: Execution Integrity}
A receipt cryptographically binds the command input, prior state, resulting state, and execution effects.
Any modification invalidates the receipt signature.

\subsection{Invariant 3: Non-Equivocation}
A device cannot produce two distinct valid receipts for the same command sequence number.
Violation implies compromise of the device private key.

\subsection{Invariant 4: Replay Resistance}
Commands include monotonic sequence numbers.
Devices reject commands with stale or duplicate sequence numbers.

\subsection{Invariant 5: Offline Verifiability}
Receipt verification requires no online interaction.
All verification inputs are contained within the receipt.

\subsection{Theorem 1: Execution Finality}
Once a valid receipt exists, execution is final and irreversible.
No external consensus or confirmation is required.

\subsection{Theorem 2: Receipt Forgery Equivalence}
Producing a valid receipt without execution is computationally equivalent to breaking the underlying post-quantum signature scheme.

\subsection{Theorem 3: Authority Compromise Containment}
Compromise of an Authority key allows unauthorized commands.
It does not allow forging execution receipts.

\subsection{Discussion}
XEQUES shifts the root of trust from command issuance to command execution.
This enables strong guarantees for autonomous systems operating in adversarial or disconnected environments.

\section{Comparative Analysis}

This section compares XEQUES against existing trust and coordination systems.
We focus on the unit of trust each system provides.

\subsection{Blockchains}
Blockchains provide consensus over ordering of transactions.
They do not prove that a real-world action was executed.
Execution is assumed, not verified.

XEQUES does not order commands globally.
Instead, it proves that a specific device executed a specific command.
Finality exists at the device level, not the network level.

\subsection{Public Key Infrastructure (PKI)}
PKI proves identity and authorization.
It does not bind authorization to execution.

XEQUES extends identity into execution.
A receipt proves not who may act, but that action occurred.

\subsection{Secure Logging Systems}
Secure logs provide tamper-evident records.
They are passive and observational.

XEQUES receipts are active.
They are generated only as a result of execution.

\subsection{Trusted Execution Environments (TEE)}
TEEs rely on hardware trust anchors and remote attestation.
They introduce vendor dependencies and centralized roots of trust.

XEQUES is hardware-agnostic.
Trust is rooted in cryptography and execution semantics, not hardware vendors.

\subsection{Why XEQUES Is New}
Existing systems prove authorization, ordering, or logging.
None treat execution as the primary cryptographic object.

XEQUES introduces execution receipts as a Layer-1 primitive.
This enables verification of real-world actions in adversarial and disconnected environments.

\section{Comparative Analysis}

This section compares XEQUES against existing trust and coordination systems.
We focus on the unit of trust each system provides.

\subsection{Blockchains}
Blockchains provide consensus over ordering of transactions.
They do not prove that a real-world action was executed.
Execution is assumed, not verified.

XEQUES does not order commands globally.
Instead, it proves that a specific device executed a specific command.
Finality exists at the device level, not the network level.

\subsection{Public Key Infrastructure (PKI)}
PKI proves identity and authorization.
It does not bind authorization to execution.

XEQUES extends identity into execution.
A receipt proves not who may act, but that action occurred.

\subsection{Secure Logging Systems}
Secure logs provide tamper-evident records.
They are passive and observational.

XEQUES receipts are active.
They are generated only as a result of execution.

\subsection{Trusted Execution Environments (TEE)}
TEEs rely on hardware trust anchors and remote attestation.
They introduce vendor dependencies and centralized roots of trust.

XEQUES is hardware-agnostic.
Trust is rooted in cryptography and execution semantics, not hardware vendors.

\subsection{Why XEQUES Is New}
Existing systems prove authorization, ordering, or logging.
None treat execution as the primary cryptographic object.

XEQUES introduces execution receipts as a Layer-1 primitive.
This enables verification of real-world actions in adversarial and disconnected environments.

\section{Threat Model}

We consider a strong adversary with the following capabilities:

\begin{itemize}
\item Full network visibility and control (eavesdropping, replay, reordering)
\item Ability to compromise command authorities
\item Long-term observation of device behavior
\item Access to classical and quantum computational resources
\end{itemize}

The adversary is assumed \textbf{unable} to:

\begin{itemize}
\item Forge post-quantum secure device signatures
\item Produce valid execution receipts without actual device execution
\item Modify a receipt without invalidating its signature
\end{itemize}

\subsection{Trust Assumptions}

XEQUES assumes the device private key remains confidential.
If the device key is compromised, security degrades explicitly and detectably.

\subsection{Security Objective}

The core security objective of XEQUES is:

\begin{quote}
\textbf{No valid execution receipt can exist without the corresponding execution occurring on the device.}
\end{quote}

This shifts trust from authorities and networks to \textit{physical execution itself}.

\section{Cryptographic Assumptions}

XEQUES relies on a minimal set of cryptographic primitives.
The security of the protocol reduces directly to the security of these primitives.

\subsection{Signature Scheme}

Each device possesses a long-term post-quantum secure signing keypair.

Required properties:

\begin{itemize}
\item Existential unforgeability under chosen-message attack (EUF-CMA)
\item Resistance to known quantum attacks
\item Deterministic or randomized signing with explicit domain separation
\end{itemize}

Concrete instantiations MAY include lattice-based schemes such as Dilithium.

\subsection{Hash Function}

A collision-resistant hash function $ is used to bind:

\begin{itemize}
\item Command contents
\item Pre-execution state
\item Post-execution state
\item Execution effects
\end{itemize}

The hash function MUST resist both classical and quantum collision attacks.

\subsection{Key Separation}

Authority keys and device keys are cryptographically distinct.
Compromise of an authority key does not enable receipt forgery.

\subsection{Cryptographic Minimalism}

XEQUES intentionally avoids:

\begin{itemize}
\item Consensus algorithms
\item Time synchronization assumptions
\item Trusted execution environments
\item Network-based trust assumptions
\end{itemize}

The protocol security depends solely on device-held secret keys and correct execution.

\section{Formal Invariants}

This section defines the invariants guaranteed by XEQUES.
These properties hold for all valid executions of the protocol.

\subsection{Invariant I: Execution Authenticity}

For any receipt $ verified under public key $,
there exists a corresponding execution of command $
by device $.

\textbf{Implication:}
No valid receipt can exist without real device execution.

\subsection{Invariant II: Non-Repudiation}

Once a receipt $ is produced by device $,
the device cannot deny having executed command $.

\textbf{Implication:}
Execution accountability is cryptographically enforced.

\subsection{Invariant III: Anti-Replay Safety}

For any two receipts , r_j$ issued by device $,
if .seq < r_j.seq$, then $ was executed before $.

\textbf{Implication:}
Command replays or reordering are detectable.

\subsection{Invariant IV: Authority Independence}

Receipt validity depends only on the device signature
and not on authority availability after execution.

\textbf{Implication:}
Post-execution verification is offline and trust-minimized.

\subsection{Invariant V: Quantum-Resilient Finality}

Assuming post-quantum signature unforgeability,
breaking any invariant requires compromise of the device key.

\textbf{Implication:}
XEQUES execution finality survives cryptographic transitions.

\section{Liveness and Failure Semantics}

XEQUES is designed for autonomous systems operating under
partial connectivity, delayed communication, and authority loss.

\subsection{Liveness Model}

A device is considered \emph{live} if it can:
\begin{itemize}
\item Verify incoming commands
\item Execute commands locally
\item Emit execution receipts
\end{itemize}

Network availability is \emph{not} required for liveness.

\subsection{Authority Failure}

If an authority becomes unavailable after issuing a command:
\begin{itemize}
\item Command execution remains valid
\item Receipts remain verifiable
\item No reauthorization is required
\end{itemize}

\textbf{Result:}
XEQUES decouples execution finality from authority uptime.

\subsection{Network Partitions}

During network partitions:
\begin{itemize}
\item Devices continue execution independently
\item Receipts are stored locally
\item Verification is deferred but not invalidated
\end{itemize}

\textbf{Result:}
XEQUES tolerates unbounded network delays.

\subsection{Device Reboots and Power Loss}

After reboot, a device resumes with:
\begin{itemize}
\item Persisted execution state
\item Monotonic sequence counters
\item Unbroken receipt chains
\end{itemize}

\textbf{Result:}
Execution history remains intact across restarts.

\subsection{Failure Safety Guarantee}

No failure mode allows:
\begin{itemize}
\item Receipt creation without execution
\item Undetectable command replay
\item Retroactive state modification
\end{itemize}

\textbf{Conclusion:}
XEQUES guarantees execution liveness without sacrificing safety.

\section{Security Proof Sketch}

This section outlines the security guarantees of XEQUES
under standard cryptographic assumptions.

\subsection{Security Objective}

The primary security goal is:

\begin{quote}
It must be computationally infeasible to produce a valid
execution receipt for a command that was not executed by the device.
\end{quote}

\subsection{Adversary Model}

The adversary is assumed to have the ability to:
\begin{itemize}
\item Observe all network traffic
\item Replay previously observed commands
\item Compromise command authorities
\item Perform adaptive chosen-message attacks
\end{itemize}

The adversary is not assumed to control the device private key.

\subsection{Unforgeability Reduction}

Assume an adversary $\mathcal{A}$ produces a valid receipt
$ for a command $ that was not executed by device $.

By construction, $ contains a signature:

\[
r = \text{Sign}_{sk_D}(H(c \parallel s \parallel s' \parallel e))
\]

If $\mathcal{A}$ did not execute $\delta(s, c)$ on $, then:
\begin{itemize}
\item Either $\mathcal{A}$ forged a signature under $, or
\item $\mathcal{A}$ obtained $
\end{itemize}

\subsection{Security Theorem}

\textbf{Theorem:}
Under the assumption that the post-quantum signature scheme is
existentially unforgeable under chosen-message attacks (EUF-CMA),
no adversary can produce a valid XEQUES receipt without executing
the corresponding command on the device.

\subsection{Implication}

Breaking XEQUES execution integrity implies breaking
post-quantum signature unforgeability or device key isolation.

\textbf{Therefore:}
XEQUES reduces execution security directly to standard
post-quantum cryptographic assumptions.
